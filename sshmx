#!/bin/bash

# Path to the sessions file
SESSIONS_FILE="$HOME/.ssh/sessions.json"

# Log file for parsing
LOG_FILE="$HOME/.ssh-session-manager.log"

# Script name for self-reference
SCRIPT_NAME="sshmx"
SCRIPT_PATH="$(realpath "$0")"

# Function to install script to PATH and tmux.conf
install_script() {
    local bin_dir="$HOME/.local/bin"
    # Create .local/bin if not exists
    mkdir -p "$bin_dir"

    # Create symlink in .local/bin
    if [[ ! -L "$bin_dir/$SCRIPT_NAME" ]]; then
        ln -sf "$SCRIPT_PATH" "$bin_dir/$SCRIPT_NAME"
        echo "Symlink created: $bin_dir/$SCRIPT_NAME -> $SCRIPT_PATH"
    else
        echo "Symlink already exists: $bin_dir/$SCRIPT_NAME"
    fi

    # Possible tmux.conf locations
    local tmux_configs=(
        "$HOME/.tmux.conf"
        "$HOME/.config/tmux.conf"
        "$HOME/.config/tmux/tmux.conf"
    )

    local tmux_conf=""

    # Find existing tmux.conf
    for conf in "${tmux_configs[@]}"; do
        if [[ -f "$conf" ]]; then
            tmux_conf="$conf"
            break
        fi
    done

    # If none exist, create ~/.tmux.conf
    if [[ -z "$tmux_conf" ]]; then
        tmux_conf="$HOME/.tmux.conf"
        mkdir -p "$HOME/.config/tmux"
        touch "$tmux_conf"
        echo "Created new tmux.conf at $tmux_conf"
    fi

    # Append tmux binding if not already present
    if ! grep -q "bind-key C-s display-popup.*sshmx" "$tmux_conf" 2>/dev/null; then
        echo 'bind-key C-s display-popup -E -w 70% -d "#{pane_current_path}" "sshmx"' >> "$tmux_conf"
        echo "Tmux binding added to $tmux_conf. Reload with 'tmux source-file $tmux_conf' or restart tmux."
    else
        echo "Tmux binding already exists in $tmux_conf."
    fi

    # Append tmux groups binding if not already present
    if ! grep -q "bind-key C-g display-popup.*sshmx.*-g" "$tmux_conf" 2>/dev/null; then
        echo 'bind-key C-g display-popup -E -w 70% -d "#{pane_current_path}" "sshmx -g"' >> "$tmux_conf"
        echo "Tmux groups binding added to $tmux_conf. Reload with 'tmux source-file $tmux_conf' or restart tmux."
    else
        echo "Tmux groups binding already exists in $tmux_conf."
    fi

    # Add .local/bin to PATH if not already
    if ! grep -q "export PATH=\"\$HOME/.local/bin:" "$HOME/.bashrc" 2>/dev/null; then
        echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$HOME/.bashrc"
        echo "Added $bin_dir to PATH in ~/.bashrc. Run 'source ~/.bashrc' to apply."
    else
        echo "$bin_dir already in PATH in ~/.bashrc."
    fi

    # Add bash completion if not already present
    if ! grep -q "_sshmx() {" "$HOME/.bashrc" 2>/dev/null; then
        cat >> "$HOME/.bashrc" << 'EOF'

_sshmx() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="--install --add --remove --sync --groups --export --import --help -i -a -r -s -g -e -p -h"

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
}

complete -F _sshmx sshmx
EOF
        echo "Bash completion added to ~/.bashrc. Run 'source ~/.bashrc' to apply."
    else
        echo "Bash completion already exists in ~/.bashrc."
    fi

    echo "Installation complete. Run 'source ~/.bashrc' and reload tmux to use $SCRIPT_NAME from anywhere. Shortcuts: Ctrl+b C-s (sessions), Ctrl+b C-g (groups)."
}

# Function to add new session interactively
add_session() {
    echo "Adding new SSH session. Follow prompts (Ctrl+C to cancel)."
    read -p "Session name: " name
    if [[ -z "$name" ]]; then
        echo "Session name cannot be empty."
        return 1
    fi

    read -p "Host/IP: " host
    if [[ -z "$host" ]]; then
        echo "Host cannot be empty."
        return 1
    fi

    read -p "User (default $USER): " user
    user=${user:-$USER}

    read -p "Port (default 22): " port
    port=${port:-22}

    read -p "Private key path (optional): " key
    read -p "Password (optional, plain text - insecure, use keys): " password
    read -p "Jump server (optional): " jump
    read -p "Group (optional): " group
    group=${group:-""}

    # Add to JSON
    jq --arg n "$name" \
       --arg h "$host" \
       --arg u "$user" \
       --arg p "$port" \
       --arg k "$key" \
       --arg pw "$password" \
       --arg j "$jump" \
       --arg g "$group" \
       '.[$n] = {host: $h, user: $u, port: ($p | tonumber), key: $k, password: $pw, jump: $j, group: $g}' \
       "$SESSIONS_FILE" > "$SESSIONS_FILE.tmp" && mv "$SESSIONS_FILE.tmp" "$SESSIONS_FILE"

    echo "Added session '$name' to $SESSIONS_FILE."
}

# Function to remove sessions interactively
remove_session() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found. Nothing to remove."
        return 1
    fi

    # Get list of session names
    session_names=$(jq -r 'keys[]' "$SESSIONS_FILE")

    if [[ -z "$session_names" ]]; then
        echo "No sessions to remove."
        return 1
    fi

    # Select sessions to remove using fzf multi-select with preview
    to_remove=$(echo "$session_names" | fzf --multi --reverse \
  --prompt="Select SSH sessions: " \
  --preview "jq -r '.\"{}\" | to_entries[] | \"\(.key): \(.value)\"' ~/.ssh/sessions.json" \
  --preview-window=right:50:border
  )


    if [[ -z "$to_remove" ]]; then
        echo "No session selected for removal."
        return 0
    fi

    # Backup sessions.json
    backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backup created: $backup_file"

    # Remove each selected session individually
    temp_file="$SESSIONS_FILE.tmp"
    cp "$SESSIONS_FILE" "$temp_file"
    for session in $to_remove; do
        if [[ -n "$session" ]]; then
            jq "del(.[\"$session\"])" "$temp_file" > "$temp_file.$$" && mv "$temp_file.$$" "$temp_file"
        fi
    done
    mv "$temp_file" "$SESSIONS_FILE"

    echo "Removed selected sessions. Backup: $backup_file"
}

# Check for flags

# Function to parse ~/.ssh/config to temporary JSON
parse_config_to_json() {
    local config_file="$HOME/.ssh/config"
    local temp_json=$(mktemp)
    echo '{}' > "$temp_json"

    echo "$(date): Starting config parsing" >> "$LOG_FILE"

    if [[ -f "$config_file" ]]; then
        echo "$(date): Parsing ~/.ssh/config file..." >> "$LOG_FILE"
        local current_host=""
        local user=""
        local hostname=""
        local port=22
        local key=""
        local jump=""

        while IFS= read -r line; do
            line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            echo "$(date): Processing line: '$line'" >> "$LOG_FILE"
            if [[ "$line" =~ ^Host[[:space:]]+(.*) ]]; then
                echo "$(date): Checking Host regex on: '$line'" >> "$LOG_FILE"
                local captured="${BASH_REMATCH[1]}"
                echo "$(date): Matched Host, captured: '$captured'" >> "$LOG_FILE"
                if [[ -n "$current_host" ]]; then
                    # Add previous host to temp_json
                    local h_host="$hostname"
                    if [[ -z "$h_host" ]]; then
                        h_host="$current_host"
                    fi
                    if [[ -z "$user" ]]; then
                        user=$(whoami)
                    fi

                    # Resolve h_host to IP if it's a hostname
                    local resolved_host="$h_host"
                    if [[ ! "$h_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        if command -v getent &> /dev/null; then
                            local temp_ip=$(getent hosts "$h_host" | awk '{print $1}' | head -n1)
                            if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                                resolved_host="$temp_ip"
                                echo "$(date): Resolved '$h_host' to IP: $resolved_host" >> "$LOG_FILE"
                            else
                                echo "$(date): Could not resolve '$h_host' to IP, using hostname" >> "$LOG_FILE"
                            fi
                        else
                            echo "$(date): getent not available, using hostname '$h_host'" >> "$LOG_FILE"
                        fi
                    fi

                    echo "$(date): Adding host '$current_host': user='$user', host='$resolved_host', port=$port, key='$key', jump='$jump'" >> "$LOG_FILE"
                    jq --arg h "$current_host" \
                       --arg hn "$resolved_host" \
                       --arg u "$user" \
                       --arg p "$port" \
                       --arg k "$key" \
                       --arg j "$jump" \
                       '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: ""}' \
                       "$temp_json" > "${temp_json}.tmp" && mv "${temp_json}.tmp" "$temp_json"
                fi
                current_host="$captured"
                if [[ -z "$current_host" ]]; then
                    echo "$(date): Invalid empty Host line: '$line'" >> "$LOG_FILE"
                    continue
                fi
                user=""
                hostname=""
                port=22
                key=""
                jump=""
                echo "$(date): Starting new host block: '$current_host'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*HostName[[:space:]]+(.*) ]]; then
                hostname="${BASH_REMATCH[1]}"
                echo "$(date): HostName: '$hostname'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*User[[:space:]]+(.*) ]]; then
                user="${BASH_REMATCH[1]}"
                echo "$(date): User: '$user'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*Port[[:space:]]+(.*) ]]; then
                port="${BASH_REMATCH[1]}"
                echo "$(date): Port: $port" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*IdentityFile[[:space:]]+(.*) ]]; then
                key="${BASH_REMATCH[1]}"
                # Expand ~ to home directory
                if [[ "$key" == ~* ]]; then
                    key=$(eval echo "$key")
                fi
                echo "$(date): IdentityFile: '$key'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*ProxyJump[[:space:]]+(.*) ]]; then
                jump="${BASH_REMATCH[1]}"
                echo "$(date): ProxyJump: '$jump'" >> "$LOG_FILE"
            else
                echo "$(date): Line did not match any pattern: '$line'" >> "$LOG_FILE"
                if [[ -n "$line" ]]; then  # Skip empty lines
                    echo "$(date): Skipping line: '$line'" >> "$LOG_FILE"
                fi
            fi
        done < "$config_file"

        # Add the last host
        if [[ -n "$current_host" ]]; then
            local h_host="$hostname"
            if [[ -z "$h_host" ]]; then
                h_host="$current_host"
            fi
            if [[ -z "$user" ]]; then
                user=$(whoami)
            fi

            # Resolve h_host to IP if it's a hostname
            local resolved_host="$h_host"
            if [[ ! "$h_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                if command -v getent &> /dev/null; then
                    local temp_ip=$(getent hosts "$h_host" | awk '{print $1}' | head -n1)
                    if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        resolved_host="$temp_ip"
                        echo "$(date): Resolved last host '$h_host' to IP: $resolved_host" >> "$LOG_FILE"
                    else
                        echo "$(date): Could not resolve last host '$h_host' to IP, using hostname" >> "$LOG_FILE"
                    fi
                else
                    echo "$(date): getent not available for last host, using hostname '$h_host'" >> "$LOG_FILE"
                fi
            fi

            echo "$(date): Adding last host '$current_host': user='$user', host='$resolved_host', port=$port, key='$key', jump='$jump'" >> "$LOG_FILE"
            jq --arg h "$current_host" \
               --arg hn "$resolved_host" \
               --arg u "$user" \
               --arg p "$port" \
               --arg k "$key" \
               --arg j "$jump" \
               '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: ""}' \
               "$temp_json" > "${temp_json}.tmp" && mv "${temp_json}.tmp" "$temp_json"
        fi
    fi

    echo "$temp_json"
}

# Function to sync sessions.json with ~/.ssh/config
sync_sessions() {
    local temp_json=$(parse_config_to_json)

    # Sync existing sessions with config
    if [[ -f "$SESSIONS_FILE" ]]; then
        echo "$(date): Syncing with existing $SESSIONS_FILE" >> "$LOG_FILE"
        local config_keys
        config_keys=$(jq -r 'keys[]' "$temp_json" 2>/dev/null || true)
        while IFS= read -r key; do
            if [[ -n "$key" ]]; then
                local hn u p id_key j current_pw
                hn=$(jq -r --arg k "$key" '.[$k].host // empty' "$temp_json")
                u=$(jq -r --arg k "$key" '.[$k].user // empty' "$temp_json")
                p=$(jq -r --arg k "$key" '.[$k].port // 22' "$temp_json")
                id_key=$(jq -r --arg k "$key" '.[$k].key // empty' "$temp_json")
                j=$(jq -r --arg k "$key" '.[$k].jump // empty' "$temp_json")
                current_pw=$(jq -r --arg k "$key" '.[$k].password // ""' "$SESSIONS_FILE")
                current_group=$(jq -r --arg k "$key" '.[$k].group // ""' "$SESSIONS_FILE")
                echo "$(date): Updating session '$key' from config (preserving password and group)" >> "$LOG_FILE"
                jq --arg h "$key" \
                   --arg hn "$hn" \
                   --arg u "$u" \
                   --arg p "$p" \
                   --arg ky "$id_key" \
                   --arg pw "$current_pw" \
                   --arg j "$j" \
                   --arg g "$current_group" \
                   '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $ky, password: $pw, jump: $j, group: $g}' \
                   "$SESSIONS_FILE" > "${SESSIONS_FILE}.tmp" && mv "${SESSIONS_FILE}.tmp" "$SESSIONS_FILE" || echo "Error updating $key" >> "$LOG_FILE"
            fi
        done <<< "$config_keys"
    else
        echo "$(date): No existing $SESSIONS_FILE, creating from config" >> "$LOG_FILE"
    fi
    
    # Ensure SESSIONS_FILE exists by copying if necessary
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        cp "$temp_json" "$SESSIONS_FILE"
    fi

    # Check if sessions empty after sync, add sample
    local num_hosts=$(jq 'keys | length' "$SESSIONS_FILE")
    if [[ "$num_hosts" -eq 0 ]]; then
        local sample_host="example.com"
        local resolved_sample="$sample_host"
        if [[ ! "$sample_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            if command -v getent &> /dev/null; then
                local temp_ip=$(getent hosts "$sample_host" | awk '{print $1}' | head -n1)
                if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    resolved_sample="$temp_ip"
                fi
            fi
        fi

        echo "$(date): No sessions found, adding sample host." >> "$LOG_FILE"
        jq --arg h "SampleHost" \
           --arg hn "$resolved_sample" \
           --arg u "youruser" \
           --arg p "22" \
           --arg k "~/.ssh/id_rsa" \
           --arg j "" \
           '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: ""}' \
           "$SESSIONS_FILE" > "${SESSIONS_FILE}.tmp" && mv "${SESSIONS_FILE}.tmp" "$SESSIONS_FILE"
    else
        local config_hosts=$(jq 'keys | length' "$temp_json" 2>/dev/null || echo 0)
        echo "$(date): Synced $config_hosts hosts from config, total $num_hosts sessions." >> "$LOG_FILE"
    fi

    rm -f "$temp_json"
    echo "Synced $SESSIONS_FILE with ~/.ssh/config."
    echo "$(date): Generated JSON content:" >> "$LOG_FILE"
    cat "$SESSIONS_FILE" >> "$LOG_FILE"
    echo "$(date): Config parsing complete" >> "$LOG_FILE"
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}
# Function to preview session details
preview_session() {
  local session="$1"
  jq -r --arg k "$session" '.[$k] | "Details for " + $k + ":\n  User: " + (.user // "N/A") + "\n  Host: " + (.host // "N/A") + "\n  Port: " + (.port | tostring // "22") + "\n  Group: " + (.group // "N/A") + (if .jump then "\n  Jump: " + .jump else "" end)' "$SESSIONS_FILE"
}

# Function to preview group sessions
preview_group() {
  local group="$1"
  jq -r --arg g "$group" ' "Sessions in group " + $g + ":\n" + (to_entries | map(select(.value.group == $g) | "  - " + .key) | join("\n")) ' "$SESSIONS_FILE"
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}


# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}

# Function to show help
show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

$SCRIPT_NAME is a bash script to manage SSH connections using fzf for selection and tmux for sessions.

Options:
    -i, --install    Install script to ~/.local/bin, add to PATH in ~/.bashrc, and add tmux binding (Ctrl+b C-s)
    -a, --add        Add a new SSH session interactively to sessions.json
    -r, --remove     Remove SSH sessions interactively from sessions.json (with backup)
    -s, --sync       Sync sessions.json with ~/.ssh/config (updates from config, preserves passwords and groups)
    -g, --groups     Select and connect to all sessions in chosen group(s)
    -e, --export     Export sessions.json to a backup file (prompts for filename if not provided)
    -p, --import     Import sessions from a JSON file (overwrites current, backs up existing)
    -h, --help       Show this help message

Without options:
    - If sessions.json doesn't exist, creates it from ~/.ssh/config (or sample)
    - Opens fzf multi-select for sessions
    - Connects selected sessions as new tmux windows in current session (if in tmux) or "sshmx" session
    - Supports keys, passwords (sshpass), jump servers (ProxyJump), chromaterm coloring, IP resolution, groups (optional field for organization)
    - Use -g to select groups instead of individual sessions
    - Tmux shortcuts: Ctrl+b C-s (individual sessions), Ctrl+b C-g (group sessions)

Sessions stored in ~/.ssh/sessions.json (JSON format: {host, user, port, key, password, jump, group}).
Logs parsing to ~/.ssh-session-manager.log.

Dependencies: jq, fzf, tmux (optional: sshpass, ct/chromaterm, getent).
EOF
}

case "$1" in
    --help|-h)
        show_help
        exit 0
        ;;
    --install|-i)
        install_script
        exit 0
        ;;
    --add|-a)
        add_session
        exit 0
        ;;
    --remove|-r)
        remove_session
        exit 0
        ;;

    --sync|-s)
        sync_sessions
        exit 0
        ;;

    --groups|-g)
        groups=$(jq -r '.[] | .group' "$SESSIONS_FILE" | grep -v '^$' | sort -u)
        selected_groups=$(echo "$groups" | fzf --multi --reverse --prompt="Select groups: " --preview 'echo "Sessions in group {}:"; jq -r --arg g {} "to_entries[] | select(.value.group == $g) | \"  - \" + .key" ~/.ssh/sessions.json' --preview-window=right:50)
        if [[ -n "$selected_groups" ]]; then
            selected=$(echo "$selected_groups" | while IFS= read -r grp; do
                if [[ -n "$grp" ]]; then
                    jq -r --arg g "$grp" 'to_entries[] | select(.value.group == $g) | .key' "$SESSIONS_FILE"
                fi
            done | sort -u | grep -v '^$')
        fi
        if [[ -z "${selected:-}" ]]; then
            echo "No groups selected."
            exit 0
        fi
        ;;

    --export|-e)
        export_sessions
        exit 0
        ;;

    --import|-p)
        import_sessions
        exit 0
        ;;
esac

# Auto-install if symlink doesn't exist
if [[ ! -L "$HOME/.local/bin/$SCRIPT_NAME" ]]; then
    echo "First run detected. Installing $SCRIPT_NAME to PATH and tmux.conf..."
    install_script
fi


# Create sessions file if it doesn't exist
if [[ ! -f "$SESSIONS_FILE" ]]; then
    temp_json=$(parse_config_to_json)
    if [[ -n "$temp_json" && -f "$temp_json" ]]; then
        cp "$temp_json" "$SESSIONS_FILE"
        rm -f "$temp_json"
    fi
    num_hosts=$(jq 'keys | length' "$SESSIONS_FILE" 2>/dev/null || echo 0)
    if [[ "$num_hosts" -eq 0 ]]; then
        sample_host="example.com"
        resolved_sample="$sample_host"
        if [[ ! "$sample_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            if command -v getent &> /dev/null; then
                temp_ip=$(getent hosts "$sample_host" | awk '{print $1}' | head -n1)
                if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    resolved_sample="$temp_ip"
                fi
            fi
        fi

        echo "$(date): No sessions found, adding sample host." >> "$LOG_FILE"
        jq --arg h "SampleHost" \
           --arg hn "$resolved_sample" \
           --arg u "youruser" \
           --arg p "22" \
           --arg k "~/.ssh/id_rsa" \
           --arg j "" \
           '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: ""}' \
           "$SESSIONS_FILE" > "${SESSIONS_FILE}.tmp" && mv "${SESSIONS_FILE}.tmp" "$SESSIONS_FILE"
    fi
    echo "Created $SESSIONS_FILE based on ~/.ssh/config (or default sample)."
    echo "$(date): Generated JSON content:" >> "$LOG_FILE"
    cat "$SESSIONS_FILE" >> "$LOG_FILE"
    echo "$(date): Config parsing complete" >> "$LOG_FILE"
fi

# Check if jq is available (required for JSON parsing)
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed."
    exit 1
fi

# Check if fzf is available
if ! command -v fzf &> /dev/null; then
    echo "Error: fzf is required but not installed."
    exit 1
fi

# Check if tmux is available
if ! command -v tmux &> /dev/null; then
    echo "Error: tmux is required but not installed."
    exit 1
fi

# Check if chromaterm (ct) is available for colorizing output
if ! command -v ct &> /dev/null; then
    echo "Warning: chromaterm (ct) not found. Install it for colored terminal output (e.g., cargo install chromaterm)."
    USE_CHROMATERM=false
else
    USE_CHROMATERM=true
fi

# Determine tmux session name
if [[ -n "$TMUX" ]]; then
    TMUX_SESSION=$(tmux display-message -p '#S')
    echo "Running inside tmux session '$TMUX_SESSION'. New connections will add windows to this session."
else
    TMUX_SESSION="sshmx"
    echo "Running outside tmux. Using dedicated session '$TMUX_SESSION'."
fi

# Function to check if tmux session exists
session_exists() {
    tmux has-session -t "$TMUX_SESSION" 2>/dev/null
}

# Create tmux session if it doesn't exist (only if not in tmux)
if [[ -z "$TMUX" ]] && ! session_exists; then
    tmux new-session -d -s "$TMUX_SESSION"
fi
# Get list of session names (keys from JSON) if not already selected via flag
if [[ -z "${selected:-}" ]]; then
    session_names=$(jq -r 'keys[]' "$SESSIONS_FILE")

    # Select sessions using fzf with multi-select and preview
    selected=$(echo "$session_names" | fzf --multi --reverse \
  --prompt="Select SSH sessions: " \
  --preview "jq -r '.\"{}\" | to_entries[] | \"\(.key): \(.value)\"' ~/.ssh/sessions.json" \
  --preview-window=right:50)



fi
if [[ -z "$selected" ]]; then
    echo "No session selected."
    exit 0
fi

# Process each selected session
echo "$selected" | while read -r sel; do
    if [[ -z "$sel" ]]; then
        continue
    fi

    # Extract user, host, port, key, password, and jump from JSON for this session
    user=$(jq -r --arg key "$sel" '.[$key].user // empty' "$SESSIONS_FILE")
    host=$(jq -r --arg key "$sel" '.[$key].host // empty' "$SESSIONS_FILE")
    port=$(jq -r --arg key "$sel" '.[$key].port // 22' "$SESSIONS_FILE")
    key=$(jq -r --arg key "$sel" '.[$key].key // empty' "$SESSIONS_FILE")
    password=$(jq -r --arg key "$sel" '.[$key].password // empty' "$SESSIONS_FILE")
    jump=$(jq -r --arg key "$sel" '.[$key].jump // empty' "$SESSIONS_FILE")

    # Expand key path if it contains ~
    if [[ -n "$key" && "$key" == ~* ]]; then
        key=$(eval echo "$key")
    fi

    # Resolve host to IP if it's a hostname (not already an IP)
    connect_host="$host"
    if [[ ! "$host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        if command -v getent &> /dev/null; then
            resolved_ip=$(getent hosts "$host" | awk '{print $1}' | head -n1)
            if [[ -n "$resolved_ip" && "$resolved_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                connect_host="$resolved_ip"
                echo "Resolved '$host' to IP: $connect_host"
            else
                echo "Warning: Could not resolve '$host' to IP, using hostname."
            fi
        else
            echo "Warning: getent not available, using hostname '$host'."
        fi
    fi

    if [[ -z "$user" ]] || [[ -z "$connect_host" ]]; then
        echo "Error: Invalid session data for '$sel'."
        continue
    fi

    if [[ -n "$jump" ]]; then
        # Get jump server info
        jump_user=$(jq -r --arg j "$jump" '.[$j].user // empty' "$SESSIONS_FILE")
        jump_host=$(jq -r --arg j "$jump" '.[$j].host // empty' "$SESSIONS_FILE")
        jump_port=$(jq -r --arg j "$jump" '.[$j].port // 22' "$SESSIONS_FILE")
        jump_key=$(jq -r --arg j "$jump" '.[$j].key // empty' "$SESSIONS_FILE")
        if [[ -z "$jump_user" ]] || [[ -z "$jump_host" ]]; then
            echo "Error: Invalid jump server '$jump' for '$sel'."
            continue
        fi

        # Create unique temp config and wrapper
        temp_config="/tmp/ssh-config-$RANDOM"
        wrapper="/tmp/ssh-wrapper-$RANDOM.sh"
        cat > "$temp_config" << EOF
Host target
    HostName $connect_host
    User $user
    Port $port
    ProxyJump $jump_user@$jump_host:$jump_port
EOF
        if [[ -n "$key" ]]; then
            echo "    IdentityFile $key" >> "$temp_config"
        fi
        if [[ -n "$jump_key" ]]; then
            echo "Host *
    IdentityFile $jump_key" >> "$temp_config"
        fi

        cat > "$wrapper" << EOF
#!/bin/bash
ssh -F $temp_config target
shred -u $temp_config
rm -f $wrapper
EOF
        chmod +x "$wrapper"

        ssh_cmd="$wrapper"
        echo "Created temp config $temp_config and wrapper $wrapper for jump connection to '$sel'. Files auto-cleaned after SSH exits."
    else
        # No jump, standard SSH
        ssh_cmd="ssh $user@$connect_host"
        if [[ "$port" != "22" ]]; then
            ssh_cmd="$ssh_cmd -p $port"
        fi

        if [[ -n "$key" ]]; then
            ssh_cmd="$ssh_cmd -i \"$key\""
        elif [[ -n "$password" ]]; then
            if command -v sshpass &> /dev/null; then
                ssh_cmd="sshpass -p '$password' $ssh_cmd"
                echo "Warning: Password stored in plain text in sessions.json - consider encrypting or using key-based auth for security."
            else
                echo "Error: sshpass not installed, cannot use stored password for '$sel'. Install with 'apt install sshpass' or use key auth."
                continue
            fi
        else
            # No key or password, ssh will prompt for password if needed
            if ! command -v sshpass &> /dev/null; then
                echo "sshpass not installed, but ssh will prompt for password if required for '$sel'."
            fi
        fi
    fi

    if [[ "$USE_CHROMATERM" == true ]]; then
        ssh_cmd="ct $ssh_cmd"
    fi

    # Create new window in the appropriate session
    tmux new-window -t "$TMUX_SESSION" -n "$sel" "$ssh_cmd"
done

# Attach to the tmux session if not already in tmux
if [[ -z "$TMUX" ]]; then
    tmux attach-session -t "$TMUX_SESSION"
fi
