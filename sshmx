#!/bin/bash

# Path to the sessions file
SESSIONS_FILE="$HOME/.ssh/sessions.json"

# Log file for parsing
LOG_FILE="$HOME/.ssh-session-manager.log"

# Script name for self-reference
SCRIPT_NAME="sshmx"
SCRIPT_PATH="$(realpath "$0")"

# Function to install script to PATH and tmux.conf
install_script() {
    local bin_dir="$HOME/.local/bin"
    # Create .local/bin if not exists
    mkdir -p "$bin_dir"

    # Create symlink in .local/bin
    if [[ ! -L "$bin_dir/$SCRIPT_NAME" ]]; then
        ln -sf "$SCRIPT_PATH" "$bin_dir/$SCRIPT_NAME"
        echo "Symlink created: $bin_dir/$SCRIPT_NAME -> $SCRIPT_PATH"
    else
        echo "Symlink already exists: $bin_dir/$SCRIPT_NAME"
    fi

    # Possible tmux.conf locations
    local tmux_configs=(
        "$HOME/.tmux.conf"
        "$HOME/.config/tmux.conf"
        "$HOME/.config/tmux/tmux.conf"
    )

    local tmux_conf=""

    # Find existing tmux.conf
    for conf in "${tmux_configs[@]}"; do
        if [[ -f "$conf" ]]; then
            tmux_conf="$conf"
            break
        fi
    done

    # If none exist, create ~/.tmux.conf
    if [[ -z "$tmux_conf" ]]; then
        tmux_conf="$HOME/.tmux.conf"
        mkdir -p "$HOME/.config/tmux"
        touch "$tmux_conf"
        echo "Created new tmux.conf at $tmux_conf"
    fi

    # Append tmux binding if not already present
    if ! grep -q "bind-key C-s display-popup.*sshmx" "$tmux_conf" 2>/dev/null; then
        echo 'bind-key C-s display-popup -E -w 70% -d "#{pane_current_path}" "sshmx"' >> "$tmux_conf"
        echo "Tmux binding added to $tmux_conf. Reload with 'tmux source-file $tmux_conf' or restart tmux."
    else
        echo "Tmux binding already exists in $tmux_conf."
    fi

    # Add .local/bin to PATH if not already
    if ! grep -q "export PATH=\"\$HOME/.local/bin:" "$HOME/.bashrc" 2>/dev/null; then
        echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$HOME/.bashrc"
        echo "Added $bin_dir to PATH in ~/.bashrc. Run 'source ~/.bashrc' to apply."
    else
        echo "$bin_dir already in PATH in ~/.bashrc."
    fi

    echo "Installation complete. Run 'source ~/.bashrc' and reload tmux to use $SCRIPT_NAME from anywhere and Ctrl+b C-s shortcut."
}

# Function to add new session interactively
add_session() {
    echo "Adding new SSH session. Follow prompts (Ctrl+C to cancel)."
    read -p "Session name: " name
    if [[ -z "$name" ]]; then
        echo "Session name cannot be empty."
        return 1
    fi

    read -p "Host/IP: " host
    if [[ -z "$host" ]]; then
        echo "Host cannot be empty."
        return 1
    fi

    read -p "User (default $USER): " user
    user=${user:-$USER}

    read -p "Port (default 22): " port
    port=${port:-22}

    read -p "Private key path (optional): " key
    read -p "Password (optional, plain text - insecure, use keys): " password
    read -p "Jump server (optional): " jump

    # Add to JSON
    jq --arg n "$name" \
       --arg h "$host" \
       --arg u "$user" \
       --arg p "$port" \
       --arg k "$key" \
       --arg pw "$password" \
       --arg j "$jump" \
       '.[$n] = {host: $h, user: $u, port: ($p | tonumber), key: $k, password: $pw, jump: $j}' \
       "$SESSIONS_FILE" > "$SESSIONS_FILE.tmp" && mv "$SESSIONS_FILE.tmp" "$SESSIONS_FILE"

    echo "Added session '$name' to $SESSIONS_FILE."
}

# Check for install flag
if [[ "$1" == "--install" ]]; then
    install_script
    exit 0
fi

# Check for add flag
if [[ "$1" == "--add" ]]; then
    add_session
    exit 0
fi

# Auto-install if symlink doesn't exist
if [[ ! -L "$HOME/.local/bin/$SCRIPT_NAME" ]]; then
    echo "First run detected. Installing $SCRIPT_NAME to PATH and tmux.conf..."
    install_script
fi

# Function to create sample sessions.json
create_sample_sessions() {
    local config_file="$HOME/.ssh/config"
    local temp_json=$(mktemp)
    echo '{}' > "$temp_json"

    echo "$(date): Starting config parsing" >> "$LOG_FILE"

    if [[ -f "$config_file" ]]; then
        echo "$(date): Parsing ~/.ssh/config file..." >> "$LOG_FILE"
        local current_host=""
        local user=""
        local hostname=""
        local port=22
        local key=""
        local jump=""

        while IFS= read -r line; do
            line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            echo "$(date): Processing line: '$line'" >> "$LOG_FILE"
            if [[ "$line" =~ ^Host[[:space:]]+(.*) ]]; then
                echo "$(date): Checking Host regex on: '$line'" >> "$LOG_FILE"
                local captured="${BASH_REMATCH[1]}"
                echo "$(date): Matched Host, captured: '$captured'" >> "$LOG_FILE"
                if [[ -n "$current_host" ]]; then
                    # Add previous host to temp_json
                    local h_host="$hostname"
                    if [[ -z "$h_host" ]]; then
                        h_host="$current_host"
                    fi
                    if [[ -z "$user" ]]; then
                        user=$(whoami)
                    fi

                    # Resolve h_host to IP if it's a hostname
                    local resolved_host="$h_host"
                    if [[ ! "$h_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        if command -v getent &> /dev/null; then
                            local temp_ip=$(getent hosts "$h_host" | awk '{print $1}' | head -n1)
                            if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                                resolved_host="$temp_ip"
                                echo "$(date): Resolved '$h_host' to IP: $resolved_host" >> "$LOG_FILE"
                            else
                                echo "$(date): Could not resolve '$h_host' to IP, using hostname" >> "$LOG_FILE"
                            fi
                        else
                            echo "$(date): getent not available, using hostname '$h_host'" >> "$LOG_FILE"
                        fi
                    fi

                    echo "$(date): Adding host '$current_host': user='$user', host='$resolved_host', port=$port, key='$key', jump='$jump'" >> "$LOG_FILE"
                    jq --arg h "$current_host" \
                       --arg hn "$resolved_host" \
                       --arg u "$user" \
                       --arg p "$port" \
                       --arg k "$key" \
                       --arg j "$jump" \
                       '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j}' \
                       "$temp_json" > "${temp_json}.tmp" && mv "${temp_json}.tmp" "$temp_json"
                fi
                current_host="$captured"
                if [[ -z "$current_host" ]]; then
                    echo "$(date): Invalid empty Host line: '$line'" >> "$LOG_FILE"
                    continue
                fi
                user=""
                hostname=""
                port=22
                key=""
                jump=""
                echo "$(date): Starting new host block: '$current_host'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*HostName[[:space:]]+(.*) ]]; then
                hostname="${BASH_REMATCH[1]}"
                echo "$(date): HostName: '$hostname'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*User[[:space:]]+(.*) ]]; then
                user="${BASH_REMATCH[1]}"
                echo "$(date): User: '$user'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*Port[[:space:]]+(.*) ]]; then
                port="${BASH_REMATCH[1]}"
                echo "$(date): Port: $port" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*IdentityFile[[:space:]]+(.*) ]]; then
                key="${BASH_REMATCH[1]}"
                # Expand ~ to home directory
                if [[ "$key" == ~* ]]; then
                    key=$(eval echo "$key")
                fi
                echo "$(date): IdentityFile: '$key'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*ProxyJump[[:space:]]+(.*) ]]; then
                jump="${BASH_REMATCH[1]}"
                echo "$(date): ProxyJump: '$jump'" >> "$LOG_FILE"
            else
                echo "$(date): Line did not match any pattern: '$line'" >> "$LOG_FILE"
                if [[ -n "$line" ]]; then  # Skip empty lines
                    echo "$(date): Skipping line: '$line'" >> "$LOG_FILE"
                fi
            fi
        done < "$config_file"

        # Add the last host
        if [[ -n "$current_host" ]]; then
            local h_host="$hostname"
            if [[ -z "$h_host" ]]; then
                h_host="$current_host"
            fi
            if [[ -z "$user" ]]; then
                user=$(whoami)
            fi

            # Resolve h_host to IP if it's a hostname
            local resolved_host="$h_host"
            if [[ ! "$h_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                if command -v getent &> /dev/null; then
                    local temp_ip=$(getent hosts "$h_host" | awk '{print $1}' | head -n1)
                    if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        resolved_host="$temp_ip"
                        echo "$(date): Resolved last host '$h_host' to IP: $resolved_host" >> "$LOG_FILE"
                    else
                        echo "$(date): Could not resolve last host '$h_host' to IP, using hostname" >> "$LOG_FILE"
                    fi
                else
                    echo "$(date): getent not available for last host, using hostname '$h_host'" >> "$LOG_FILE"
                fi
            fi

            echo "$(date): Adding last host '$current_host': user='$user', host='$resolved_host', port=$port, key='$key', jump='$jump'" >> "$LOG_FILE"
            jq --arg h "$current_host" \
               --arg hn "$resolved_host" \
               --arg u "$user" \
               --arg p "$port" \
               --arg k "$key" \
               --arg j "$jump" \
               '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j}' \
               "$temp_json" > "${temp_json}.tmp" && mv "${temp_json}.tmp" "$temp_json"
        fi
    fi

    # If no hosts were added, add sample
    local num_hosts=$(jq 'keys | length' "$temp_json")
    if [[ "$num_hosts" -eq 0 ]]; then
        local sample_host="example.com"
        local resolved_sample="$sample_host"
        if [[ ! "$sample_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            if command -v getent &> /dev/null; then
                local temp_ip=$(getent hosts "$sample_host" | awk '{print $1}' | head -n1)
                if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    resolved_sample="$temp_ip"
                fi
            fi
        fi

        echo "$(date): No hosts found in config, adding sample host." >> "$LOG_FILE"
        jq --arg h "SampleHost" \
           --arg hn "$resolved_sample" \
           --arg u "youruser" \
           --arg p "22" \
           --arg k "~/.ssh/id_rsa" \
           --arg j "" \
           '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j}' \
           "$temp_json" > "${temp_json}.tmp" && mv "${temp_json}.tmp" "$temp_json"
    else
        echo "$(date): Added $num_hosts hosts from config." >> "$LOG_FILE"
    fi

    # Write to file
    cp "$temp_json" "$SESSIONS_FILE"
    rm -f "$temp_json" "${temp_json}.tmp"
    echo "Created sample $SESSIONS_FILE based on ~/.ssh/config (or default sample."
    echo "$(date): Generated JSON content:" >> "$LOG_FILE"
    cat "$SESSIONS_FILE" >> "$LOG_FILE"
    echo "$(date): Config parsing complete" >> "$LOG_FILE"
}

# Check if sessions file exists
if [[ ! -f "$SESSIONS_FILE" ]]; then
    create_sample_sessions
fi

# Check if jq is available (required for JSON parsing)
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed."
    exit 1
fi

# Check if fzf is available
if ! command -v fzf &> /dev/null; then
    echo "Error: fzf is required but not installed."
    exit 1
fi

# Check if tmux is available
if ! command -v tmux &> /dev/null; then
    echo "Error: tmux is required but not installed."
    exit 1
fi

# Check if chromaterm (ct) is available for colorizing output
if ! command -v ct &> /dev/null; then
    echo "Warning: chromaterm (ct) not found. Install it for colored terminal output (e.g., cargo install chromaterm)."
    USE_CHROMATERM=false
else
    USE_CHROMATERM=true
fi

# Determine tmux session name
if [[ -n "$TMUX" ]]; then
    TMUX_SESSION=$(tmux display-message -p '#S')
    echo "Running inside tmux session '$TMUX_SESSION'. New connections will add windows to this session."
else
    TMUX_SESSION="sshmx"
    echo "Running outside tmux. Using dedicated session '$TMUX_SESSION'."
fi

# Function to check if tmux session exists
session_exists() {
    tmux has-session -t "$TMUX_SESSION" 2>/dev/null
}

# Create tmux session if it doesn't exist (only if not in tmux)
if [[ -z "$TMUX" ]] && ! session_exists; then
    tmux new-session -d -s "$TMUX_SESSION"
fi

# Get list of session names (keys from JSON)
session_names=$(jq -r 'keys[]' "$SESSIONS_FILE")

# Select sessions using fzf with multi-select
selected=$(echo "$session_names" | fzf --multi --prompt="Select SSH sessions: " --height=20)

if [[ -z "$selected" ]]; then
    echo "No session selected."
    exit 0
fi

# Process each selected session
echo "$selected" | while read -r sel; do
    if [[ -z "$sel" ]]; then
        continue
    fi

    # Extract user, host, port, key, password, and jump from JSON for this session
    user=$(jq -r --arg key "$sel" '.[$key].user // empty' "$SESSIONS_FILE")
    host=$(jq -r --arg key "$sel" '.[$key].host // empty' "$SESSIONS_FILE")
    port=$(jq -r --arg key "$sel" '.[$key].port // 22' "$SESSIONS_FILE")
    key=$(jq -r --arg key "$sel" '.[$key].key // empty' "$SESSIONS_FILE")
    password=$(jq -r --arg key "$sel" '.[$key].password // empty' "$SESSIONS_FILE")
    jump=$(jq -r --arg key "$sel" '.[$key].jump // empty' "$SESSIONS_FILE")

    # Expand key path if it contains ~
    if [[ -n "$key" && "$key" == ~* ]]; then
        key=$(eval echo "$key")
    fi

    # Resolve host to IP if it's a hostname (not already an IP)
    connect_host="$host"
    if [[ ! "$host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        if command -v getent &> /dev/null; then
            resolved_ip=$(getent hosts "$host" | awk '{print $1}' | head -n1)
            if [[ -n "$resolved_ip" && "$resolved_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                connect_host="$resolved_ip"
                echo "Resolved '$host' to IP: $connect_host"
            else
                echo "Warning: Could not resolve '$host' to IP, using hostname."
            fi
        else
            echo "Warning: getent not available, using hostname '$host'."
        fi
    fi

    if [[ -z "$user" ]] || [[ -z "$connect_host" ]]; then
        echo "Error: Invalid session data for '$sel'."
        continue
    fi

    if [[ -n "$jump" ]]; then
        # Get jump server info
        jump_user=$(jq -r --arg j "$jump" '.[$j].user // empty' "$SESSIONS_FILE")
        jump_host=$(jq -r --arg j "$jump" '.[$j].host // empty' "$SESSIONS_FILE")
        jump_port=$(jq -r --arg j "$jump" '.[$j].port // 22' "$SESSIONS_FILE")
        jump_key=$(jq -r --arg j "$jump" '.[$j].key // empty' "$SESSIONS_FILE")
        if [[ -z "$jump_user" ]] || [[ -z "$jump_host" ]]; then
            echo "Error: Invalid jump server '$jump' for '$sel'."
            continue
        fi

        # Create unique temp config and wrapper
        temp_config="/tmp/ssh-config-$RANDOM"
        wrapper="/tmp/ssh-wrapper-$RANDOM.sh"
        cat > "$temp_config" << EOF
Host target
    HostName $connect_host
    User $user
    Port $port
    ProxyJump $jump_user@$jump_host:$jump_port
EOF
        if [[ -n "$key" ]]; then
            echo "    IdentityFile $key" >> "$temp_config"
        fi
        if [[ -n "$jump_key" ]]; then
            echo "Host *
    IdentityFile $jump_key" >> "$temp_config"
        fi

        cat > "$wrapper" << EOF
#!/bin/bash
ssh -F $temp_config target
shred -u $temp_config
rm -f $wrapper
EOF
        chmod +x "$wrapper"

        ssh_cmd="$wrapper"
        echo "Created temp config $temp_config and wrapper $wrapper for jump connection to '$sel'. Files auto-cleaned after SSH exits."
    else
        # No jump, standard SSH
        ssh_cmd="ssh $user@$connect_host"
        if [[ "$port" != "22" ]]; then
            ssh_cmd="$ssh_cmd -p $port"
        fi

        if [[ -n "$key" ]]; then
            ssh_cmd="$ssh_cmd -i \"$key\""
        elif [[ -n "$password" ]]; then
            if command -v sshpass &> /dev/null; then
                ssh_cmd="sshpass -p '$password' $ssh_cmd"
                echo "Warning: Password stored in plain text in sessions.json - consider encrypting or using key-based auth for security."
            else
                echo "Error: sshpass not installed, cannot use stored password for '$sel'. Install with 'apt install sshpass' or use key auth."
                continue
            fi
        else
            # No key or password, ssh will prompt for password if needed
            if ! command -v sshpass &> /dev/null; then
                echo "sshpass not installed, but ssh will prompt for password if required for '$sel'."
            fi
        fi
    fi

    if [[ "$USE_CHROMATERM" == true ]]; then
        ssh_cmd="ct $ssh_cmd"
    fi

    # Create new window in the appropriate session
    tmux new-window -t "$TMUX_SESSION" -n "$sel" "$ssh_cmd"
done

# Attach to the tmux session if not already in tmux
if [[ -z "$TMUX" ]]; then
    tmux attach-session -t "$TMUX_SESSION"
fi
