#!/bin/bash

# Path to the sessions file
SESSIONS_FILE="$HOME/.ssh/sessions.json"

# Log file for parsing
LOG_FILE="$HOME/.sshmx.log"

# Script name for self-reference
SCRIPT_NAME="sshmx"
SCRIPT_PATH="$(realpath "$0")"

# Function to install script to PATH and tmux.conf
install_script() {
    local bin_dir="$HOME/.local/bin"
    # Create .local/bin if not exists
    mkdir -p "$bin_dir"

    # Create symlink in .local/bin
    if [[ ! -L "$bin_dir/$SCRIPT_NAME" ]]; then
        ln -sf "$SCRIPT_PATH" "$bin_dir/$SCRIPT_NAME"
        echo "Symlink created: $bin_dir/$SCRIPT_NAME -> $SCRIPT_PATH"
    else
        echo "Symlink already exists: $bin_dir/$SCRIPT_NAME"
    fi

    # Possible tmux.conf locations
    local tmux_configs=(
        "$HOME/.tmux.conf"
        "$HOME/.config/tmux.conf"
        "$HOME/.config/tmux/tmux.conf"
    )

    local tmux_conf=""

    # Find existing tmux.conf
    for conf in "${tmux_configs[@]}"; do
        if [[ -f "$conf" ]]; then
            tmux_conf="$conf"
            break
        fi
    done

    # If none exist, create ~/.tmux.conf
    if [[ -z "$tmux_conf" ]]; then
        tmux_conf="$HOME/.tmux.conf"
        mkdir -p "$HOME/.config/tmux"
        touch "$tmux_conf"
        echo "Created new tmux.conf at $tmux_conf"
    fi

    # Append tmux binding if not already present
    if ! grep -q "bind-key C-s display-popup.*sshmx" "$tmux_conf" 2>/dev/null; then
        echo 'bind-key C-s display-popup -E -w 70% -d "#{pane_current_path}" "sshmx"' >> "$tmux_conf"
        echo "Tmux binding added to $tmux_conf. Reload with 'tmux source-file $tmux_conf' or restart tmux."
    else
        echo "Tmux binding already exists in $tmux_conf."
    fi
    # Append tmux groups binding if not already present
    if ! grep -q "bind-key C-g display-popup.*sshmx.*-g" "$tmux_conf" 2>/dev/null; then
        echo 'bind-key C-g display-popup -E -w 70% -d "#{pane_current_path}" "sshmx -g"' >> "$tmux_conf"
        echo "Tmux groups binding added to $tmux_conf. Reload with 'tmux source-file $tmux_conf' or restart tmux."
    else
        echo "Tmux groups binding already exists in $tmux_conf."
    fi

    # Append tmux binding for demultiplex (Ctrl+b C-q) if not already present
    if ! grep -q "bind-key C-q run-shell 'bash sshmx -d'" "$tmux_conf" 2>/dev/null; then
        echo "bind-key C-q run-shell 'bash sshmx -d'" >> "$tmux_conf"
        echo "Tmux demultiplex binding added to $tmux_conf."
    else
        echo "Tmux demultiplex binding already exists in $tmux_conf."
    fi

    # Append tmux binding for multiplex (Ctrl+b C-m) if not already present
    if ! grep -q "bind-key C-m display-popup.*sshmx -m" "$tmux_conf" 2>/dev/null; then
        echo 'bind-key C-m display-popup -E -w 90% -h 80% -d "#{pane_current_path}" "sshmx -m"' >> "$tmux_conf"
        echo "Tmux multiplex binding added to $tmux_conf."
    else
        echo "Tmux multiplex binding already exists in $tmux_conf."
    fi
    # Add .local/bin to PATH if not already
    if ! grep -q "export PATH=\"\$HOME/.local/bin:" "$HOME/.bashrc" 2>/dev/null; then
        echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$HOME/.bashrc"
        echo "Added $bin_dir to PATH in ~/.bashrc. Run 'source ~/.bashrc' to apply."
    else
        echo "$bin_dir already in PATH in ~/.bashrc."
    fi

    # Add bash completion if not already present
    if ! grep -q "_sshmx() {" "$HOME/.bashrc" 2>/dev/null; then
        cat >> "$HOME/.bashrc" << 'EOF'

_sshmx() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="--install --add --remove --sync --groups --export --import --help -i -a -r -s -g -e -p -h"

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
}

complete -F _sshmx sshmx
EOF
        echo "Bash completion added to ~/.bashrc. Run 'source ~/.bashrc' to apply."
    else
        echo "Bash completion already exists in ~/.bashrc."
    fi

    echo "Installation complete. Run 'source ~/.bashrc' and reload tmux to use $SCRIPT_NAME from anywhere. Shortcuts: Ctrl+b C-s (sessions), Ctrl+b C-g (groups)."
}

# Function to add new session interactively
add_session() {
    echo "Adding new SSH session. Follow prompts (Ctrl+C to cancel)."
    read -p "Session name: " name
    if [[ -z "$name" ]]; then
        echo "Session name cannot be empty."
        return 1
    fi

    read -p "Host/IP: " host
    if [[ -z "$host" ]]; then
        echo "Host cannot be empty."
        return 1
    fi

    read -p "User (default $USER): " user
    user=${user:-$USER}

    read -p "Port (default 22): " port
    port=${port:-22}

    read -p "Private key path (optional): " key
    read -p "Password (optional, plain text - insecure, use keys): " password
    read -p "Jump server (optional): " jump
    read -p "Group (optional): " group
    group=${group:-""}
    read -p "Background color(optional): " bg_color
    read -p "Foreground color(optional): " fg_color

    # Add to JSON
    jq --arg n "$name" \
       --arg h "$host" \
       --arg u "$user" \
       --arg p "$port" \
       --arg k "$key" \
       --arg pw "$password" \
       --arg j "$jump" \
       --arg g "$group" \
       --arg bg "$bg_color" \
       --arg fg "$fg_color" \
       '.[$n] = {host: $h, user: $u, port: ($p | tonumber), key: $k, password: $pw, jump: $j, group: $g, bg_color: $bg, fg_color: $fg}' \
       "$SESSIONS_FILE" > "$SESSIONS_FILE.tmp" && mv "$SESSIONS_FILE.tmp" "$SESSIONS_FILE"

    echo "Added session '$name' to $SESSIONS_FILE."
}

# Function to remove sessions interactively
remove_session() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found. Nothing to remove."
        return 1
    fi

    # Get list of session names
    session_names=$(jq -r 'keys[]' "$SESSIONS_FILE")

    if [[ -z "$session_names" ]]; then
        echo "No sessions to remove."
        return 1
    fi

    # Select sessions to remove using fzf multi-select with preview
    to_remove=$(echo "$session_names" | fzf --multi --reverse \
  --prompt="Select SSH sessions: " \
  --preview "jq -r '.\"{}\" | to_entries[] | \"\(.key): \(.value)\"' ~/.ssh/sessions.json" \
  --preview-window=right:50:border
  )


    if [[ -z "$to_remove" ]]; then
        echo "No session selected for removal."
        return 0
    fi

    # Backup sessions.json
    backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backup created: $backup_file"

    # Remove each selected session individually
    temp_file="$SESSIONS_FILE.tmp"
    cp "$SESSIONS_FILE" "$temp_file"
    for session in $to_remove; do
        if [[ -n "$session" ]]; then
            jq "del(.[\"$session\"])" "$temp_file" > "$temp_file.$$" && mv "$temp_file.$$" "$temp_file"
        fi
    done
    mv "$temp_file" "$SESSIONS_FILE"

    echo "Removed selected sessions. Backup: $backup_file"
}

# Check for flags

# Function to parse ~/.ssh/config to temporary JSON
parse_config_to_json() {
    local config_file="$HOME/.ssh/config"
    local temp_json=$(mktemp)
    echo '{}' > "$temp_json"

    echo "$(date): Starting config parsing" >> "$LOG_FILE"

    if [[ -f "$config_file" ]]; then
        echo "$(date): Parsing ~/.ssh/config file..." >> "$LOG_FILE"
        local current_host=""
        local user=""
        local hostname=""
        local port=22
        local key=""
        local jump=""

        while IFS= read -r line; do
            line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            echo "$(date): Processing line: '$line'" >> "$LOG_FILE"
            if [[ "$line" =~ ^Host[[:space:]]+(.*) ]]; then
                echo "$(date): Checking Host regex on: '$line'" >> "$LOG_FILE"
                local captured="${BASH_REMATCH[1]}"
                echo "$(date): Matched Host, captured: '$captured'" >> "$LOG_FILE"
                if [[ -n "$current_host" ]]; then
                    # Add previous host to temp_json
                    local h_host="$hostname"
                    if [[ -z "$h_host" ]]; then
                        h_host="$current_host"
                    fi
                    if [[ -z "$user" ]]; then
                        user=$(whoami)
                    fi

                    # Resolve h_host to IP if it's a hostname
                    local resolved_host="$h_host"
                    if [[ ! "$h_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        if command -v getent &> /dev/null; then
                            local temp_ip=$(getent hosts "$h_host" | awk '{print $1}' | head -n1)
                            if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                                resolved_host="$temp_ip"
                                echo "$(date): Resolved '$h_host' to IP: $resolved_host" >> "$LOG_FILE"
                            else
                                echo "$(date): Could not resolve '$h_host' to IP, using hostname" >> "$LOG_FILE"
                            fi
                        else
                            echo "$(date): getent not available, using hostname '$h_host'" >> "$LOG_FILE"
                        fi
                    fi

                    echo "$(date): Adding host '$current_host': user='$user', host='$resolved_host', port=$port, key='$key', jump='$jump'" >> "$LOG_FILE"
                    jq --arg h "$current_host" \
                       --arg hn "$resolved_host" \
                       --arg u "$user" \
                       --arg p "$port" \
                       --arg k "$key" \
                       --arg j "$jump" \
                       '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: "", bg_color: "", fg_color: ""}' \
                       "$temp_json" > "${temp_json}.tmp" && mv "${temp_json}.tmp" "$temp_json"
                fi
                current_host="$captured"
                if [[ -z "$current_host" ]]; then
                    echo "$(date): Invalid empty Host line: '$line'" >> "$LOG_FILE"
                    continue
                fi
                user=""
                hostname=""
                port=22
                key=""
                jump=""
                echo "$(date): Starting new host block: '$current_host'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*HostName[[:space:]]+(.*) ]]; then
                hostname="${BASH_REMATCH[1]}"
                echo "$(date): HostName: '$hostname'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*User[[:space:]]+(.*) ]]; then
                user="${BASH_REMATCH[1]}"
                echo "$(date): User: '$user'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*Port[[:space:]]+(.*) ]]; then
                port="${BASH_REMATCH[1]}"
                echo "$(date): Port: $port" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*IdentityFile[[:space:]]+(.*) ]]; then
                key="${BASH_REMATCH[1]}"
                # Expand ~ to home directory
                if [[ "$key" == ~* ]]; then
                    key=$(eval echo "$key")
                fi
                echo "$(date): IdentityFile: '$key'" >> "$LOG_FILE"
            elif [[ "$line" =~ ^[[:space:]]*ProxyJump[[:space:]]+(.*) ]]; then
                jump="${BASH_REMATCH[1]}"
                echo "$(date): ProxyJump: '$jump'" >> "$LOG_FILE"
            else
                echo "$(date): Line did not match any pattern: '$line'" >> "$LOG_FILE"
                if [[ -n "$line" ]]; then  # Skip empty lines
                    echo "$(date): Skipping line: '$line'" >> "$LOG_FILE"
                fi
            fi
        done < "$config_file"

        # Add the last host
        if [[ -n "$current_host" ]]; then
            local h_host="$hostname"
            if [[ -z "$h_host" ]]; then
                h_host="$current_host"
            fi
            if [[ -z "$user" ]]; then
                user=$(whoami)
            fi

            # Resolve h_host to IP if it's a hostname
            local resolved_host="$h_host"
            if [[ ! "$h_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                if command -v getent &> /dev/null; then
                    local temp_ip=$(getent hosts "$h_host" | awk '{print $1}' | head -n1)
                    if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        resolved_host="$temp_ip"
                        echo "$(date): Resolved last host '$h_host' to IP: $resolved_host" >> "$LOG_FILE"
                    else
                        echo "$(date): Could not resolve last host '$h_host' to IP, using hostname" >> "$LOG_FILE"
                    fi
                else
                    echo "$(date): getent not available for last host, using hostname '$h_host'" >> "$LOG_FILE"
                fi
            fi

            echo "$(date): Adding last host '$current_host': user='$user', host='$resolved_host', port=$port, key='$key', jump='$jump'" >> "$LOG_FILE"
            jq --arg h "$current_host" \
               --arg hn "$resolved_host" \
               --arg u "$user" \
               --arg p "$port" \
               --arg k "$key" \
               --arg j "$jump" \
               '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: "", bg_color: "", fg_color: ""}' \
               "$temp_json" > "${temp_json}.tmp" && mv "${temp_json}.tmp" "$temp_json"
        fi
    fi

    echo "$temp_json"
}

# Function to sync sessions.json with ~/.ssh/config
sync_sessions() {
    local temp_json=$(parse_config_to_json)

    # Sync existing sessions with config
    if [[ -f "$SESSIONS_FILE" ]]; then
        echo "$(date): Syncing with existing $SESSIONS_FILE" >> "$LOG_FILE"
        local config_keys
        config_keys=$(jq -r 'keys[]' "$temp_json" 2>/dev/null || true)
        while IFS= read -r key; do
            if [[ -n "$key" ]]; then
                local hn u p id_key j current_pw
                hn=$(jq -r --arg k "$key" '.[$k].host // empty' "$temp_json")
                u=$(jq -r --arg k "$key" '.[$k].user // empty' "$temp_json")
                p=$(jq -r --arg k "$key" '.[$k].port // 22' "$temp_json")
                id_key=$(jq -r --arg k "$key" '.[$k].key // empty' "$temp_json")
                j=$(jq -r --arg k "$key" '.[$k].jump // empty' "$temp_json")
                current_pw=$(jq -r --arg k "$key" '.[$k].password // ""' "$SESSIONS_FILE")
                current_group=$(jq -r --arg k "$key" '.[$k].group // ""' "$SESSIONS_FILE")
                current_bg_color=$(jq -r --arg k "$key" '.[$k].bg_color // ""' "$SESSIONS_FILE")
                current_fg_color=$(jq -r --arg k "$key" '.[$k].fg_color // ""' "$SESSIONS_FILE")
                echo "$(date): Updating session '$key' from config (preserving password and group)" >> "$LOG_FILE"
                jq --arg h "$key" \
                   --arg hn "$hn" \
                   --arg u "$u" \
                   --arg p "$p" \
                   --arg ky "$id_key" \
                   --arg pw "$current_pw" \
                   --arg j "$j" \
                   --arg g "$current_group" \
                   --arg bg "$current_bg_color" \
                   --arg fg "$current_fg_color" \
                   '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $ky, password: $pw, jump: $j, group: $g, bg_color: $bg, fg_color: $fg}' \
                   "$SESSIONS_FILE" > "${SESSIONS_FILE}.tmp" && mv "${SESSIONS_FILE}.tmp" "$SESSIONS_FILE" || echo "Error updating $key" >> "$LOG_FILE"
            fi
        done <<< "$config_keys"
    else
        echo "$(date): No existing $SESSIONS_FILE, creating from config" >> "$LOG_FILE"
    fi
    
    # Ensure SESSIONS_FILE exists by copying if necessary
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        cp "$temp_json" "$SESSIONS_FILE"
    fi

    # Check if sessions empty after sync, add sample
    local num_hosts=$(jq 'keys | length' "$SESSIONS_FILE")
    if [[ "$num_hosts" -eq 0 ]]; then
        local sample_host="example.com"
        local resolved_sample="$sample_host"
        if [[ ! "$sample_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            if command -v getent &> /dev/null; then
                local temp_ip=$(getent hosts "$sample_host" | awk '{print $1}' | head -n1)
                if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    resolved_sample="$temp_ip"
                fi
            fi
        fi

        echo "$(date): No sessions found, adding sample host." >> "$LOG_FILE"
        jq --arg h "SampleHost" \
           --arg hn "$resolved_sample" \
           --arg u "youruser" \
           --arg p "22" \
           --arg k "~/.ssh/id_rsa" \
           --arg j "" \
           '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: "", bg_color: "", fg_color: ""}' \
           "$SESSIONS_FILE" > "${SESSIONS_FILE}.tmp" && mv "${SESSIONS_FILE}.tmp" "$SESSIONS_FILE"
    else
        local config_hosts=$(jq 'keys | length' "$temp_json" 2>/dev/null || echo 0)
        echo "$(date): Synced $config_hosts hosts from config, total $num_hosts sessions." >> "$LOG_FILE"
    fi

    rm -f "$temp_json"
    echo "Synced $SESSIONS_FILE with ~/.ssh/config."
    echo "$(date): Generated JSON content:" >> "$LOG_FILE"
    cat "$SESSIONS_FILE" >> "$LOG_FILE"
    echo "$(date): Config parsing complete" >> "$LOG_FILE"
}

# Function to connect to a group

group_connect() {
    groups=$(jq -r '.[] | .group' "$SESSIONS_FILE" | grep -v '^$' | sort -u)
    selected_groups=$(echo "$groups" | fzf --multi --reverse --prompt="Select groups to connect to all hosts: ")
    if [[ -n "$selected_groups" ]]; then
        selected=$(echo "$selected_groups" | while IFS= read -r grp; do
            if [[ -n "$grp" ]]; then
                jq -r --arg g "$grp" 'to_entries[] | select(.value.group == $g) | .key' "$SESSIONS_FILE"
            fi
        done | sort -u | grep -v '^$')
    fi
    if [[ -z "${selected:-}" ]]; then
        echo "No groups selected."
        exit 0
    fi
}

# Function to export sessions.json
export_sessions() {
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No sessions.json found to export."
        return 1
    fi

    local export_file
    if [[ -n "$2" ]]; then
        export_file="$2"
    else
        read -p "Enter export filename (default: sessions-backup-$(date +%Y%m%d_%H%M%S).json): " export_file
        export_file=${export_file:-"sessions-backup-$(date +%Y%m%d_%H%M%S).json"}
    fi

    cp "$SESSIONS_FILE" "$export_file"
    echo "Exported sessions to $export_file."
}

# Function to import sessions.json
import_sessions() {
    local import_file
    if [[ -n "$2" ]]; then
        import_file="$2"
    else
        read -p "Enter import filename: " import_file
    fi

    if [[ ! -f "$import_file" ]]; then
        echo "Import file not found: $import_file"
        return 1
    fi

    if [[ ! -f "$SESSIONS_FILE" ]]; then
        echo "No existing sessions.json, creating from import."
        cp "$import_file" "$SESSIONS_FILE"
        echo "Imported sessions from $import_file."
        return 0
    fi

    # Backup current
    local backup_file="$SESSIONS_FILE.backup-$(date +%Y%m%d_%H%M%S)"
    cp "$SESSIONS_FILE" "$backup_file"
    echo "Backed up current sessions to $backup_file."

    # Overwrite with import
    cp "$import_file" "$SESSIONS_FILE"
    echo "Imported sessions from $import_file (overwrote existing)."
}

# multiplex: merge selected windows into a single "sync-input" window
multiplex() {
    local session="sshmx"
    local target_window="sync-input"
    local LOG_FILE="${HOME}/.sshmx.log"
    local MAP_FILE="${HOME}/.sshmx-mapping"

    echo "$(date '+%F %T') [INFO] Starting multiplex" >> "$LOG_FILE"

    # 0) safety: don't allow a pre-existing sync-input
    if tmux list-windows -t "$session" -F "#{window_name}" \
       | grep -xq "$target_window"; then
        echo "$(date '+%F %T') [WARN] $target_window already exists; aborting multiplex." | tee -a "$LOG_FILE"
        return 1
    fi

    # 1) pick windows (we include window_id to keep references stable)
    local selection
    selection=$(tmux list-windows -t "$session" -F "#S:#I:#W:#{window_id}" \
        | fzf --multi --reverse --prompt="Select windows > " \
              --preview '
                  win_id=$(echo {} | cut -d: -f4);
                  pane=$(tmux list-panes -t "$win_id" -F "#{pane_id}" 2>/dev/null | head -n1);
                  [ -n "$pane" ] && tmux capture-pane -pt "$pane" -S -20 || echo "No pane found"
              ' --preview-window=down:70%) || return 1

    [[ -z "$selection" ]] && echo "$(date '+%F %T') [INFO] No windows selected." >> "$LOG_FILE" && return 1

    # prepare mapping (overwrite any old mapping)
    : > "$MAP_FILE"
    echo "$(date '+%F %T') [INFO] Mapping file: $MAP_FILE" >> "$LOG_FILE"

    # read selections into array
    mapfile -t windows <<< "$selection"

    # 2) handle the first selected window: record its panes' mapping BEFORE rename
    local first="${windows[0]}"
    local first_id=$(echo "$first" | cut -d: -f4)
    local first_name=$(echo "$first" | cut -d: -f3)
    if [[ -z "$first_id" ]]; then
        echo "$(date '+%F %T') [ERROR] Unable to parse first window id. Aborting." >> "$LOG_FILE"
        return 1
    fi

    # record every pane in first window
    local p
    mapfile -t first_panes < <(tmux list-panes -t "$first_id" -F "#{pane_id}" 2>/dev/null || true)
    for p in "${first_panes[@]}"; do
        # format: pane_id|original_window_name
        printf "%s|%s\n" "$p" "$first_name" >> "$MAP_FILE"
        echo "$(date '+%F %T') [DEBUG] MAPPED %s -> %s" "$p" "$first_name" >> "$LOG_FILE"
    done

    # rename the first selected window to target
    tmux rename-window -t "$first_id" "$target_window"
    echo "$(date '+%F %T') [INFO] Renamed window id $first_id -> $target_window" >> "$LOG_FILE"

    # 3) for each remaining selected window: record panes, then join them into target
    local i
    for (( i=1; i<${#windows[@]}; i++ )); do
        local w="${windows[$i]}"
        local win_id=$(echo "$w" | cut -d: -f4)
        local win_name=$(echo "$w" | cut -d: -f3)

        echo "$(date '+%F %T') [INFO] Processing window id $win_id (name: $win_name)" >> "$LOG_FILE"

        # list panes in that window (by pane_id)
        mapfile -t panes < <(tmux list-panes -t "$win_id" -F "#{pane_id}" 2>/dev/null || true)
        if [[ ${#panes[@]} -eq 0 ]]; then
            echo "$(date '+%F %T') [WARN] No panes found for window id $win_id" >> "$LOG_FILE"
            continue
        fi

        for p in "${panes[@]}"; do
            # record mapping before moving
            printf "%s|%s\n" "$p" "$win_name" >> "$MAP_FILE"
            echo "$(date '+%F %T') [DEBUG] MAPPED %s -> %s" "$p" "$win_name" >> "$LOG_FILE"

            # move the pane into the target window
            tmux join-pane -s "$p" -t "${session}:${target_window}"
            if [[ $? -ne 0 ]]; then
                echo "$(date '+%F %T') [ERROR] join-pane failed for pane $p" >> "$LOG_FILE"
            else
                echo "$(date '+%F %T') [INFO] Joined pane $p into ${session}:${target_window}" >> "$LOG_FILE"
            fi
            # slight pause can help with tmux state consistency on busy systems
            sleep 0.03
        done

        # kill the now-empty original window (best-effort)
        tmux kill-window -t "$win_id" 2>/dev/null
        echo "$(date '+%F %T') [INFO] Killed original window id $win_id" >> "$LOG_FILE"
    done

    # 4) enable sync and tidy layout
    tmux setw -t "${session}:${target_window}" synchronize-panes on
    tmux select-layout -t "${session}:${target_window}" tiled
    echo "$(date '+%F %T') [INFO] Completed multiplex; mapping saved to $MAP_FILE" >> "$LOG_FILE"
}

# demultiplex: reverse the mapping file -> break panes into windows and restore names
demultiplex() {
    local session="sshmx"
    local target_window="sync-input"
    local LOG_FILE="${HOME}/.sshmx.log"
    local MAP_FILE="${HOME}/.sshmx-mapping"

    echo "$(date '+%F %T') [INFO] Starting demultiplex" >> "$LOG_FILE"

    if [[ ! -f "$MAP_FILE" ]]; then
        echo "$(date '+%F %T') [WARN] No mapping file ($MAP_FILE) found. Aborting." >> "$LOG_FILE"
        return 1
    fi

    # process each mapping line: pane_id|original_window_name
    while IFS='|' read -r pane orig_name; do
        # skip empty lines
        [[ -z "$pane" ]] && continue

        # confirm pane exists somewhere (list all panes)
        if ! tmux list-panes -a -F "#{pane_id}" | grep -Fxq "$pane"; then
            echo "$(date '+%F %T') [WARN] Pane $pane not found; skipping" >> "$LOG_FILE"
            continue
        fi

        # break the pane into a new window (detached)
        tmux break-pane -s "$pane" -d
        if [[ $? -ne 0 ]]; then
            echo "$(date '+%F %T') [ERROR] break-pane failed for $pane" >> "$LOG_FILE"
            continue
        fi

        # find the new window id which now contains this pane
        new_win_id=$(tmux list-panes -a -F "#{pane_id} #{window_id}" \
                     | awk -v p="$pane" '$1==p { print $2; exit }')

        if [[ -z "$new_win_id" ]]; then
            echo "$(date '+%F %T') [ERROR] Could not find new window for pane $pane" >> "$LOG_FILE"
            continue
        fi

        # restore original name (if empty, use fallback)
        if [[ -z "$orig_name" ]]; then
            orig_name="restored-window"
        fi

        # attempt to rename
        tmux rename-window -t "$new_win_id" "$orig_name"
        if [[ $? -ne 0 ]]; then
            echo "$(date '+%F %T') [WARN] rename-window failed for $new_win_id -> $orig_name; trying fallback name" >> "$LOG_FILE"
            tmux rename-window -t "$new_win_id" "${orig_name}-restored" 2>/dev/null
        fi

        echo "$(date '+%F %T') [INFO] Restored pane $pane -> window '$orig_name' (id: $new_win_id)" >> "$LOG_FILE"
    done < "$MAP_FILE"

    # remove the mapping file after successful demultiplex
    rm -f "$MAP_FILE"
    echo "$(date '+%F %T') [INFO] Demultiplex finished; removed mapping file $MAP_FILE" >> "$LOG_FILE"

    # finally, if sync-input still exists and has zero panes, kill it
    if tmux list-windows -t "$session" -F "#{window_name}:#{window_panes}" \
       | awk -F: -v w="$target_window" '$1==w && $2==0 { exit 0 } END { if (NR==0) exit 1 }'; then
        tmux kill-window -t "${session}:${target_window}" 2>/dev/null
        echo "$(date '+%F %T') [INFO] Removed empty $target_window window" >> "$LOG_FILE"
    fi
}


# Function to preview session details
preview_session() {
  local session="$1"
  jq -r --arg k "$session" '.[$k] | "Details for " + $k + ":\n  User: " + (.user // "N/A") + "\n  Host: " + (.host // "N/A") + "\n  Port: " + (.port | tostring // "22") + "\n  Group: " + (.group // "N/A") + (if .jump then "\n  Jump: " + .jump else "" end)' "$SESSIONS_FILE"
}

# Function to preview group sessions
preview_group() {
  local group="$1"
  jq -r --arg g "$group" ' "Sessions in group " + $g + ":\n" + (to_entries | map(select(.value.group == $g) | "  - " + .key) | join("\n")) ' "$SESSIONS_FILE"
}

# Function to show help
show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

$SCRIPT_NAME is a bash script to manage SSH connections using fzf for selection and tmux for sessions.

Options:
    -i, --install        Install script to ~/.local/bin, add to PATH in ~/.bashrc, and add tmux binding (Ctrl+b C-s)
    -a, --add            Add a new SSH session interactively to sessions.json
    -r, --remove         Remove SSH sessions interactively from sessions.json (with backup)
    -s, --sync           Sync sessions.json with ~/.ssh/config (updates from config, preserves passwords and groups)
    -g, --groups         Select and connect to all sessions in chosen group(s)
    -m, --multiplex      Open multiplex selector (Ctrl+b C-m) to combine windows into a synchronized pane window
    -d, --demultiplex    Restore panes from a multiplexed window back to separate windows (Ctrl+b C-q)
    -e, --export         Export sessions.json to a backup file (prompts for filename if not provided)
    -p, --import         Import sessions from a JSON file (overwrites current, backs up existing)
    -h, --help           Show this help message

Without options:
    - If sessions.json doesn't exist, creates it from ~/.ssh/config (or sample)
    - Opens fzf multi-select for sessions
    - Connects selected sessions as new tmux windows in current session (if in tmux) or "sshmx" session
    - Supports keys, passwords (sshpass), jump servers (ProxyJump), chromaterm coloring, IP resolution, groups (optional field for organization)
    - Use -g to select groups, -m for multiplex, -d for demultiplex
    - Tmux shortcuts: Ctrl+b C-s (sessions), Ctrl+b C-g (groups), Ctrl+b C-m (multiplex), Ctrl+b C-q (demultiplex)

Sessions stored in ~/.ssh/sessions.json (JSON format: {host, user, port, key, password, jump, group}).
Logs parsing to ~/.ssh-session-manager.log.

Dependencies: jq, fzf, tmux (optional: sshpass, ct/chromaterm, getent).
EOF
}

case "$1" in
    --help|-h)
        show_help
        exit 0
        ;;
    --install|-i)
        install_script
        exit 0
        ;;
    --add|-a)
        add_session
        exit 0
        ;;
    --remove|-r)
        remove_session
        exit 0
        ;;

    --sync|-s)
        sync_sessions
        exit 0
        ;;

    --groups|-g)
        group_connect
        ;;

    --multiplex|-m)
        multiplex
        exit 0
        ;;

    --demultiplex|-d)
        demultiplex
        ;;

    --export|-e)
        export_sessions
        exit 0
        ;;

    --import|-p)
        import_sessions
        exit 0
        ;;
esac

# Auto-install if symlink doesn't exist
if [[ ! -L "$HOME/.local/bin/$SCRIPT_NAME" ]]; then
    echo "First run detected. Installing $SCRIPT_NAME to PATH and tmux.conf..."
    install_script
fi

# Create sessions file if it doesn't exist
if [[ ! -f "$SESSIONS_FILE" ]]; then
    temp_json=$(parse_config_to_json)
    if [[ -n "$temp_json" && -f "$temp_json" ]]; then
        cp "$temp_json" "$SESSIONS_FILE"
        rm -f "$temp_json"
    fi
    num_hosts=$(jq 'keys | length' "$SESSIONS_FILE" 2>/dev/null || echo 0)
    if [[ "$num_hosts" -eq 0 ]]; then
        sample_host="example.com"
        resolved_sample="$sample_host"
        if [[ ! "$sample_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            if command -v getent &> /dev/null; then
                temp_ip=$(getent hosts "$sample_host" | awk '{print $1}' | head -n1)
                if [[ -n "$temp_ip" && "$temp_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    resolved_sample="$temp_ip"
                fi
            fi
        fi

        echo "$(date): No sessions found, adding sample host." >> "$LOG_FILE"
        jq --arg h "SampleHost" \
           --arg hn "$resolved_sample" \
           --arg u "youruser" \
           --arg p "22" \
           --arg k "~/.ssh/id_rsa" \
           --arg j "" \
           '.[$h] = {host: $hn, user: $u, port: ($p | tonumber), key: $k, password: "", jump: $j, group: "", bg_color: "", fg_color: ""}' \
           "$SESSIONS_FILE" > "${SESSIONS_FILE}.tmp" && mv "${SESSIONS_FILE}.tmp" "$SESSIONS_FILE"
    fi
    echo "Created $SESSIONS_FILE based on ~/.ssh/config (or default sample)."
    echo "$(date): Generated JSON content:" >> "$LOG_FILE"
    cat "$SESSIONS_FILE" >> "$LOG_FILE"
    echo "$(date): Config parsing complete" >> "$LOG_FILE"
fi

# Check if jq is available (required for JSON parsing)
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed."
    exit 1
fi

# Check if fzf is available
if ! command -v fzf &> /dev/null; then
    echo "Error: fzf is required but not installed."
    exit 1
fi

# Check if tmux is available
if ! command -v tmux &> /dev/null; then
    echo "Error: tmux is required but not installed."
    exit 1
fi

# Check if chromaterm (ct) is available for colorizing output
if ! command -v ct &> /dev/null; then
    echo "Warning: chromaterm (ct) not found. Install it for colored terminal output (e.g., cargo install chromaterm)."
    USE_CHROMATERM=false
else
    USE_CHROMATERM=true
fi

# Determine tmux session name
if [[ -n "$TMUX" ]]; then
    TMUX_SESSION=$(tmux display-message -p '#S')
    echo "$(date): Running inside tmux session '$TMUX_SESSION'. New connections will add windows to this session." >> $LOG_FILE
else
    TMUX_SESSION="sshmx"
    echo "$(date): Running outside tmux. Using dedicated session '$TMUX_SESSION'." >> $LOG_FILE
fi

# Function to check if tmux session exists
session_exists() {
    tmux has-session -t "$TMUX_SESSION" 2>/dev/null
}

# Create tmux session if it doesn't exist (only if not in tmux)
if [[ -z "$TMUX" ]] && ! session_exists; then
    tmux new-session -d -s "$TMUX_SESSION"
fi

# Get list of session names (keys from JSON) if not already selected via flag
if [[ -z "${selected:-}" ]]; then
    session_names=$(jq -r 'keys[]' "$SESSIONS_FILE")

    # Select sessions using fzf with multi-select and preview
    selected=$(echo "$session_names" | fzf --multi --reverse \
  --prompt="Select SSH sessions: " \
  --preview "jq -r '.\"{}\" | to_entries[] | \"\(.key): \(.value)\"' ~/.ssh/sessions.json" \
  --preview-window=right:50)
fi

if [[ -z "$selected" ]]; then
    echo "No session selected."
    exit 0
fi

# Process each selected session
echo "$selected" | while read -r sel; do
    if [[ -z "$sel" ]]; then
        continue
    fi

    # Extract user, host, port, key, password, and jump from JSON for this session
    user=$(jq -r --arg key "$sel" '.[$key].user // empty' "$SESSIONS_FILE")
    host=$(jq -r --arg key "$sel" '.[$key].host // empty' "$SESSIONS_FILE")
    port=$(jq -r --arg key "$sel" '.[$key].port // 22' "$SESSIONS_FILE")
    key=$(jq -r --arg key "$sel" '.[$key].key // empty' "$SESSIONS_FILE")
    password=$(jq -r --arg key "$sel" '.[$key].password // empty' "$SESSIONS_FILE")
    jump=$(jq -r --arg key "$sel" '.[$key].jump // empty' "$SESSIONS_FILE")
    bg_color=$(jq -r --arg key "$sel" '.[$key].bg_color // empty' "$SESSIONS_FILE")
    fg_color=$(jq -r --arg key "$sel" '.[$key].fg_color // empty' "$SESSIONS_FILE")

    # Expand key path if it contains ~
    if [[ -n "$key" && "$key" == ~* ]]; then
        key=$(eval echo "$key")
    fi

    # Resolve host to IP if it's a hostname (not already an IP)
    connect_host="$host"
    if [[ ! "$host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        if command -v getent &> /dev/null; then
            resolved_ip=$(getent hosts "$host" | awk '{print $1}' | head -n1)
            if [[ -n "$resolved_ip" && "$resolved_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                connect_host="$resolved_ip"
                echo "Resolved '$host' to IP: $connect_host"
            else
                echo "Warning: Could not resolve '$host' to IP, using hostname."
            fi
        else
            echo "Warning: getent not available, using hostname '$host'."
        fi
    fi

    if [[ -z "$user" ]] || [[ -z "$connect_host" ]]; then
        echo "Error: Invalid session data for '$sel'."
        continue
    fi

    if [[ -n "$jump" ]]; then
        # Get jump server info
        jump_user=$(jq -r --arg j "$jump" '.[$j].user // empty' "$SESSIONS_FILE")
        jump_host=$(jq -r --arg j "$jump" '.[$j].host // empty' "$SESSIONS_FILE")
        jump_port=$(jq -r --arg j "$jump" '.[$j].port // 22' "$SESSIONS_FILE")
        jump_key=$(jq -r --arg j "$jump" '.[$j].key // empty' "$SESSIONS_FILE")
        if [[ -z "$jump_user" ]] || [[ -z "$jump_host" ]]; then
            echo "Error: Invalid jump server '$jump' for '$sel'."
            continue
        fi

        # Create unique temp config and wrapper
        temp_config="/tmp/ssh-config-$RANDOM"
        wrapper="/tmp/ssh-wrapper-$RANDOM.sh"
        cat > "$temp_config" << EOF
Host target
    HostName $connect_host
    User $user
    Port $port
    ProxyJump $jump_user@$jump_host:$jump_port
EOF
        if [[ -n "$key" ]]; then
            echo "    IdentityFile $key" >> "$temp_config"
        fi
        if [[ -n "$jump_key" ]]; then
            echo "Host *
    IdentityFile $jump_key" >> "$temp_config"
        fi

        cat > "$wrapper" << EOF
#!/bin/bash
ssh -F $temp_config target
shred -u $temp_config
rm -f $wrapper
EOF
        chmod +x "$wrapper"

        ssh_cmd="$wrapper"
        echo "$(date): Created temp config $temp_config and wrapper $wrapper for jump connection to '$sel'. Files auto-cleaned after SSH exits." >> $LOG_FILE
    else
        # No jump, standard SSH
        ssh_cmd="ssh $user@$connect_host"
        if [[ "$port" != "22" ]]; then
            ssh_cmd="$ssh_cmd -p $port"
        fi

        if [[ -n "$key" ]]; then
            ssh_cmd="$ssh_cmd -i \"$key\""
        elif [[ -n "$password" ]]; then
            if command -v sshpass &> /dev/null; then
                ssh_cmd="sshpass -p '$password' $ssh_cmd"
                echo "Warning: Password stored in plain text in sessions.json - consider encrypting or using key-based auth for security."
            else
                echo "Error: sshpass not installed, cannot use stored password for '$sel'. Install with 'apt install sshpass' or use key auth."
                continue
            fi
        else
            # No key or password, ssh will prompt for password if needed
            if ! command -v sshpass &> /dev/null; then
                echo "sshpass not installed, but ssh will prompt for password if required for '$sel'."
            fi
        fi
    fi

    if [[ "$USE_CHROMATERM" == true ]]; then
        ssh_cmd="ct $ssh_cmd"
    fi

    # Create new window in the appropriate session
    tmux new-window -t "$TMUX_SESSION" -n "$sel" "$ssh_cmd"
done

# Attach to the tmux session if not already in tmux
if [[ -z "$TMUX" ]]; then
    tmux attach-session -t "$TMUX_SESSION"
fi
